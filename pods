// Amelia Lipińska 203721 
// Alicja Szajgin 203383
// GRA PASJANS KLODLIKE
#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <ctime>
#include <cstdlib>
#include <iomanip>


using namespace std;
const int MAX_C = 52;

//STALE DLA KART:

const int KIER = 0;
const int KARO = 1;
const int TREFL = 2;
const int PIK = 3;

const int CZARNY = 0;
const int CZERWONY = 1;
//KARTY
struct Card
{
    //wyglad karty-charakterystyka
    int value = 0;
    int shape = 0; //0->kier, 1->karo, 2->trefl, 3->pik
    int color = 0; //czarny to wartosc 0 a czerwony 1

    bool is_face_up = 0; //czy karta jaest widoczna
    string card_description; //opis karty->kier 2 trefl 3 itd

    //konstruktor domyslny->mówi że tworzymy kartę (nie trzeba tego robic wtedy recznie)
    Card() {}
    //ustalanie kart
    Card(int val, int sha, int col)
    {
        //ustawienie wartosci value-> A dama 2,3...
        value = val;
        //ksztalt karty->kier...
        shape = sha;
        is_face_up = false; //na poczatku karta jest zakryta

        //ustawienie wartosci dla kart

        //tablica figór
        string card_shape[] = { "H", "D", "C", "S" };
        //tablica wartosci
        string card_value[] = { "", "A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K" };

        //stworzona karta:
        card_description = card_shape[shape] + card_value[value];

        //ustawienie koloru

        color = (shape == KIER || shape == KARO) ? CZERWONY : CZARNY;
    }

};

class Gameplay {
    Card deck[MAX_C];
    queue<Card> choice;

    vector<Card> pile1, pile2, pile3, pile4, pile5, pile6, pile7;
    vector<vector<Card>> h1_7 = { pile1, pile2, pile3, pile4, pile5, pile6, pile7 };

    stack<Card> s8, s9, s10, s11;
    vector<stack<Card>> s8_11 = { s8, s9, s10, s11 };

public:

    //deklaracje funkcji
    void generujTalie();
    void rozdaj();
    void printNaglowek();
    void printLinia();
    void printGora();
    void printDol();
    void printNumeracja();
    void wyswietlPlansze();

    void Menu();
    void przeniesKarte(int zKolumny, int doKolumny);
};

void Gameplay::generujTalie() {
    int index = 0;
    for (int shape = 0; shape < 4; ++shape) {
        for (int val = 1; val <= 13; ++val) {
            deck[index++] = Card(val, shape, (shape == KIER || shape == KARO) ? CZERWONY : CZARNY);
        }
    }

    srand(static_cast<unsigned int>(time(0)));

    for (int i = MAX_C - 1; i > 0; --i) {
        int j = rand() % (i + 1);
        swap(deck[i], deck[j]);
    }
}

void Gameplay::rozdaj() {
    int position = 0;
    for (int i = 0; i < 7; ++i) {
        for (int j = 0; j <= i; ++j) {
            h1_7[i].push_back(deck[position]);
            if (j == i) h1_7[i][j].is_face_up = true;
            position++;
        }
    }

    for (int i = position; i < MAX_C; ++i) {
        choice.push(deck[i]);
    }
};

void Gameplay::printNaglowek() {
    cout << "      0                    8      9      10     11\n";  // Przesunięcie o 6
}

void Gameplay::printLinia() {
    cout << "   --------------------------------------------------\n";
}

void Gameplay::printGora() {
    cout << "      ";  // Przesunięcie o 6
    if (!choice.empty())
        cout << setw(6) << left << choice.front().card_description;
    else
        cout << setw(6) << "0";  // Dodanie odpowiedniego odstępu

    cout << "               ";
    for (int i = 0; i < 4; i++) {
        if (!s8_11[i].empty())
            cout << setw(7) << left << s8_11[i].top().card_description;
        else
            cout << setw(7) << left << "0";  // Dodanie odpowiedniego odstępu
    }
    cout << endl;
}

void Gameplay::printDol() {
    const int STALA_WYSOKOSC = 15;

    for (int i = 0; i < STALA_WYSOKOSC; i++) {
        cout << "   ";  // Pozostawiamy to tak, jak było, bez przesunięcia
        for (int j = 0; j < 7; j++) {
            cout << "| ";
            if (i < h1_7[j].size()) {
                if (h1_7[j][i].is_face_up)
                    cout << setw(4) << left << h1_7[j][i].card_description << " ";
                else
                    cout << "===  ";
            }
            else {
                cout << "     ";
            }
        }
        cout << "|\n";
    }
}

void Gameplay::printNumeracja() {
    cout << "       ";  // Pozostawiamy numerację tak, jak była
    for (int i = 1; i <= 7; i++) {
        cout << setw(7) << i;
    }
    cout << endl;
};

void Gameplay::wyswietlPlansze() {
    printNaglowek();
    printLinia();
    printGora();
    printLinia();
    printDol();
    printNumeracja();
};

//RUCHY

void Gameplay::Menu() {
    int z, do_;

    generujTalie();         //  tasowanie i stworzenie talii
    rozdaj();      //  rozłożenie na kolumny

    while (true)
    {
        wyswietlPlansze();

        cout << "\nPRZENIESIENIE KARTY.\n";
        cout << "Podaj numer kolumny z(1-7): ";
        cin >> z;
        cout << "Podaj numer kolumny do(1-7): ";
        cin >> do_;

        przeniesKarte(z - 1, do_ - 1);
    }
}
//rzeniesienie karty z jednego studiku na drugi:

void Gameplay::przeniesKarte(int zKolumny, int doKolumny)
{
    //sprawdzenie czy indeksy kolumn są poprawne
    if (zKolumny < 0 || zKolumny >= 7 || doKolumny < 0 || doKolumny >= 7) {
        cout << "Nieprawidlowy indeks kolumny.\n";
        return;
    }

    //przypisanie kolumn do zmiennych
    vector<Card>& z_ = h1_7[zKolumny];
    vector<Card>& do_ = h1_7[doKolumny];

    //sprawdzenie czy wogóle jest jakas karta
    if (z_.empty()) {
        cout << "Kolumna Z jest pusta.\n";
        return;
    }

    Card karta = z_.back();

    //sprawdzenie czy karta jest zakryta
    if (!karta.is_face_up) {
        cout << "Nie mozna przeniesc zakrytej karty.\n";
        return;
    }

    //jezeli miejsce jest puste to może byc tylko król
    if (do_.empty())
    {
        if (karta.value != 13)
        {
            cout << "Tylko krola można przeniesc na pustą kolumne.\n";
            return;
        }
    }
        else
        {
            Card top = do_.back();

            if (top.color == karta.color)
            {
                cout << "Nie mozna przenieść karty o tym samym kolorze.\n";
                return;
            }
            if (top.value != karta.value + 1)
            {
                cout << "Nie mozna przeniesc karty o tej samej wartosci.\n";
                return;
            }
        }

    do_.push_back(karta);
    z_.pop_back();

    // Odkryj nową ostatnią kartę jeśli istnieje
    if (!z_.empty()) {
        z_.back().is_face_up = true;
    }

    cout << "Przeniesiono karte " << karta.card_description << " z kolumny " << zKolumny + 1 << " do kolumny " << doKolumny + 1 << ".\n";
}



int main()
{
    //stworzenie obiektu gry
    Gameplay gra;
    //wywołanie menu
    gra.Menu();
    return 0;
}
