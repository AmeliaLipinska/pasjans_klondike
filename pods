// Amelia Lipińska 203721 
// Alicja Szajgin 203383
// GRA PASJANS KLODLIKE
#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <ctime>
#include <cstdlib>
#include <iomanip>


using namespace std;
const int MAX_C = 52;

//STALE DLA KART:

const int KIER = 0;
const int KARO = 1;
const int TREFL = 2;
const int PIK = 3;

const int CZARNY = 0;
const int CZERWONY = 1;
//KARTY
struct Card
{
    //wyglad karty-charakterystyka
    int value = 0;
    int shape = 0; //0->kier, 1->karo, 2->trefl, 3->pik
    int color = 0; //czarny to wartosc 0 a czerwony 1

    bool is_face_up = 0; //czy karta jaest widoczna
    string card_description; //opis karty->kier 2 trefl 3 itd

    //konstruktor domyslny->mówi że tworzymy kartę (nie trzeba tego robic wtedy recznie)
    Card() {}
    //ustalanie kart
    Card(int val, int sha, int col)
    {
        //ustawienie wartosci value-> A dama 2,3...
        value = val;
        //ksztalt karty->kier...
        shape = sha;
        is_face_up = false; //na poczatku karta jest zakryta

        //ustawienie wartosci dla kart

        //tablica figór
        string card_shape[] = { "H", "D", "C", "S" };
        //tablica wartosci
        string card_value[] = { "", "A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K" };

        //stworzona karta:
        card_description = card_shape[shape] + card_value[value];

        //ustawienie koloru

        color = (shape == KIER || shape == KARO) ? CZERWONY : CZARNY;
    }

};

class Gameplay {
    Card deck[MAX_C];
    queue<Card> choice;

    vector<Card> pile1, pile2, pile3, pile4, pile5, pile6, pile7;
    vector<vector<Card>> h1_7 = { pile1, pile2, pile3, pile4, pile5, pile6, pile7 };

    stack<Card> s8, s9, s10, s11;
    vector<stack<Card>> s8_11 = { s8, s9, s10, s11 };

public:

    //deklaracje funkcji
    void generujTalie();
    void rozdaj();
    void printNaglowek();
    void printLinia();
    void printGora();
    void printDol();
    void printNumeracja();
    void wyswietlPlansze();

    void Menu();
	void dobierzKarty();
	void ruchKolumnaNaKolumne(int z, string kartaStr, int d);
	void ruchKolumnaNaStos(int z, string kartaStr, int d);
	void ruchChoiceNaKolumne(string kartaStr, int d);
	void ruchChoiceNaStos(string kartaStr, int d);
    bool Wygrana();
};

void Gameplay::generujTalie() {
    int index = 0;
    for (int shape = 0; shape < 4; ++shape) {
        for (int val = 1; val <= 13; ++val) {
            deck[index++] = Card(val, shape, (shape == KIER || shape == KARO) ? CZERWONY : CZARNY);
        }
    }

    srand(static_cast<unsigned int>(time(0)));

    for (int i = MAX_C - 1; i > 0; --i) {
        int j = rand() % (i + 1);
        swap(deck[i], deck[j]);
    }
}

void Gameplay::rozdaj() {
    int position = 0;
    for (int i = 0; i < 7; ++i) {
        for (int j = 0; j <= i; ++j) {
            h1_7[i].push_back(deck[position]);
            if (j == i) h1_7[i][j].is_face_up = true;
            position++;
        }
    }

    for (int i = position; i < MAX_C; ++i) {

        choice.push(deck[i]);
    }
};

void Gameplay::printNaglowek() {
    cout << "      0                    8      9      10     11\n";  // Przesunięcie o 6
}

void Gameplay::printLinia() {
    cout << "   --------------------------------------------------\n";
}

void Gameplay::printGora() {
    cout << "      ";  // Przesunięcie o 6
    if (!choice.empty())
        cout << setw(6) << left << choice.front().card_description;
    else
        cout << setw(6) << "0";  // Dodanie odpowiedniego odstępu

    cout << "               ";
    for (int i = 0; i < 4; i++) {
        if (!s8_11[i].empty())
            cout << setw(7) << left << s8_11[i].top().card_description;
        else
            cout << setw(7) << left << "0";  // Dodanie odpowiedniego odstępu
    }
    cout << endl;
}

void Gameplay::printDol() {
    const int STALA_WYSOKOSC = 15;

    for (int i = 0; i < STALA_WYSOKOSC; i++) {
        cout << "   ";  // Pozostawiamy to tak, jak było, bez przesunięcia
        for (int j = 0; j < 7; j++) {
            cout << "| ";
            if (i < h1_7[j].size()) {
                if (h1_7[j][i].is_face_up)
                    cout << setw(4) << left << h1_7[j][i].card_description << " ";
                else
                    cout << "===  ";
            }
            else {
                cout << "     ";
            }
        }
        cout << "|\n";
    }
}

void Gameplay::printNumeracja() {
    cout << "       ";  // Pozostawiamy numerację tak, jak była
    for (int i = 1; i <= 7; i++) {
        cout << setw(7) << i;
    }
    cout << endl;
};

void Gameplay::wyswietlPlansze() {
    printNaglowek();
    printLinia();
    printGora();
    printLinia();
    printDol();
    printNumeracja();
};

//RUCHY

void Gameplay::Menu() {
    int z, d;
    string kartaStr;

    generujTalie();
    rozdaj();

    while (!Wygrana())
    {
        wyswietlPlansze();

        cout << "\n>> ";
        cin >> z;

        Wygrana();

        if (z == 0 && cin.peek() == '\n') {
            dobierzKarty();
            continue;
        }

        cin >> kartaStr >> d;

        if (z >= 1 && z <= 7 && d >= 1 && d <= 7) {
            ruchKolumnaNaKolumne(z, kartaStr, d);
        }
        else if (z >= 1 && z <= 7 && d >= 8 && d <= 11) {
            ruchKolumnaNaStos(z, kartaStr, d);
        }
        else if (z == 0 && d >= 1 && d <= 7) {
            ruchChoiceNaKolumne(kartaStr, d);
        }
        else if (z == 0 && d >= 8 && d <= 11) {
            ruchChoiceNaStos(kartaStr, d);
        }
        else {
            cout << "Nieprawidłowa komenda.\n";
        }
    }
}

void Gameplay::dobierzKarty() {
    int ile = min(3, (int)choice.size());
    for (int i = 0; i < ile; ++i) {
        Card temp = choice.front();
        choice.pop();
        temp.is_face_up = true;
        choice.push(temp);
    }
}

void Gameplay::ruchKolumnaNaKolumne(int z, string kartaStr, int d) {
    vector<Card>& kolumna = h1_7[z - 1];

    int idx = -1;
    for (int i = 0; i < kolumna.size(); ++i) {
        if (kolumna[i].card_description == kartaStr && kolumna[i].is_face_up) {
            idx = i;
            break;
        }
    }

    if (idx == -1) {
        cout << "Nie znaleziono odkrytej karty " << kartaStr << " w kolumnie " << z << ".\n";
        return;
    }

    vector<Card> tymczasowe(kolumna.begin() + idx, kolumna.end());
    vector<Card>& cel = h1_7[d - 1];

    if (!cel.empty()) {
        Card& top = cel.back();
        if (top.color == tymczasowe[0].color || top.value != tymczasowe[0].value + 1) {
            cout << "Nie można polozyc – kolor lub wartość się nie zgadza.\n";
            return;
        }
    }
    else {
        if (tymczasowe[0].value != 13) {
            cout << "Na pustą kolumnę mozna polozyc tylko krola.\n";
            return;
        }
    }

    kolumna.erase(kolumna.begin() + idx, kolumna.end());
    cel.insert(cel.end(), tymczasowe.begin(), tymczasowe.end());
    if (!kolumna.empty()) kolumna.back().is_face_up = true;
}

void Gameplay::ruchKolumnaNaStos(int z, string kartaStr, int d) {
    vector<Card>& kolumna = h1_7[z - 1];
    if (kolumna.empty() || !kolumna.back().is_face_up) {
        cout << "Brak odkrytej karty na końcu kolumny.\n";
        return;
    }

    Card karta = kolumna.back();
    if (karta.card_description != kartaStr) {
        cout << "Na końcu kolumny nie ma " << kartaStr << ".\n";
        return;
    }

    stack<Card>& stos = s8_11[d - 8];
    if (stos.empty()) {
        if (karta.value != 1) {
            cout << "Na pusty stos można położyć tylko Asa.\n";
            return;
        }
    }
    else {
        Card top = stos.top();
        if (top.shape != karta.shape || karta.value != top.value + 1) {
            cout << "Nieprawidłowy ruch do stosu końcowego.\n";
            return;
        }
    }

    stos.push(karta);
    kolumna.pop_back();
    if (!kolumna.empty()) kolumna.back().is_face_up = true;
}

void Gameplay::ruchChoiceNaKolumne(string kartaStr, int d) {
    if (choice.empty()) {
        cout << "Stos dobierania pusty.\n";
        return;
    }

    Card pierwsza = choice.front();
    if (pierwsza.card_description != kartaStr) {
        cout << "Pierwsza karta w kolejce to nie " << kartaStr << ".\n";
        return;
    }

    vector<Card>& cel = h1_7[d - 1];

    if (!cel.empty()) {
        Card& top = cel.back();
        if (top.color == pierwsza.color || top.value != pierwsza.value + 1) {
            cout << "Nie można położyć tej karty na kolumnę.\n";
            return;
        }
    }
    else {
        if (pierwsza.value != 13) {
            cout << "Na pustą kolumnę tylko król.\n";
            return;
        }
    }

    choice.pop();
    pierwsza.is_face_up = true;
    cel.push_back(pierwsza);
}

void Gameplay::ruchChoiceNaStos(string kartaStr, int d) {
    if (choice.empty()) {
        cout << "Stos dobierania pusty.\n";
        return;
    }

    Card pierwsza = choice.front();
    if (pierwsza.card_description != kartaStr) {
        cout << "Pierwsza karta w kolejce to nie " << kartaStr << ".\n";
        return;
    }

    stack<Card>& stos = s8_11[d - 8];
    if (stos.empty()) {
        if (pierwsza.value != 1) {
            cout << "Na pusty stos tylko As.\n";
            return;
        }
    }
    else {
        Card top = stos.top();
        if (top.shape != pierwsza.shape || pierwsza.value != top.value + 1) {
            cout << "Nieprawidłowy ruch.\n";
            return;
        }
    }

    choice.pop();
    pierwsza.is_face_up = true;
    stos.push(pierwsza);
}

//funkcja wygranej- kiedy 4 stosy sa zapełnione 

bool Gameplay::Wygrana()
{
    for (int i = 0; i < 4; i++)
    {
        //sprawdza czy jest 13 kart na kazdym stosie, jak sa to ttrue a jak nie to false
        if (s8_11[i].size()!=13)
        {
            return false;
        }
    }
    return true;
}

int main()
{
    //stworzenie obiektu gry
    Gameplay gra;
    //wywołanie menu
    gra.Menu();
    return 0;
}
